@using IntegrationV3R_PortailFournisseur.Data.Models;﻿
@using Microsoft.EntityFrameworkCore;

@inject IJSRuntime JSRuntime
@inject IntegrationV3R_PortailFournisseur.Data.Models.ApplicationDbContext dbContext

<div class="container-fluid mt-4">
    <form class="form" @onsubmit="HandleSubmit">

        <!-- Product Description -->
        <div class="mb-3">
            <label for="productDescriptionInput" class="form-label">Description du produit</label>
            <textarea class="form-control" id="productDescriptionInput" @bind="SingletonForm.DescriptionProduitsServicesInput" maxlength="500"></textarea>
            @if (!string.IsNullOrEmpty(productDescriptionError))
            {
                <div class="text-danger">@productDescriptionError</div>
            }
        </div>

        <!-- Product Search -->
        <div class="mb-3">
            <label for="productSearchInput" class="form-label">Rechercher des produits</label>
            <input type="text" class="form-control" id="productSearchInput" @bind="productSearch" @oninput="OnProductSearchInput" placeholder="Recherchez des produits..." />

            @if (filteredProducts != null && filteredProducts.Any())
            {
                <!-- Add a div wrapper with a fixed height and overflow-y to enable scrolling -->
                <div class="overflow-auto" style="max-height: 200px;">
                    <ul class="list-group" id="productResults">
                        @foreach (var product in filteredProducts)
                        {
                            <li class="list-group-item d-flex justify-content-between align-items-center" @onclick="() => SelectProduct(product)">
                                @product.ComoditeNombre - @product.ComoditeTitreFr                                
                            </li>
                        }
                    </ul>
                </div>
            }

            @if (!string.IsNullOrEmpty(productSearchError))
            {
                <div class="text-danger">@productSearchError</div>
            }
        </div>


        <!-- Selected Products -->
        <div class="mb-3">
            <h5>Produits sélectionnés</h5>
            <ul>
                @if (SingletonForm.ProduitsServicesSelectionnesInput.Any())
                {
                    foreach (var product in SingletonForm.ProduitsServicesSelectionnesInput)
                    {
                        <li>
                            <strong>@product.ComoditeNombre - @product.ComoditeTitreFr</strong>
                            <button type="button" class="btn btn-link text-danger btn-sm" @onclick="() => RemoveProduct(product)" style="margin-left: 10px; padding: 0;">&times;</button>
                        </li>
                    }
                }
                else
                {
                    <li>Aucun produit sélectionné.</li>
                }
            </ul>
        </div>

        <button type="submit" class="btn btn-primary">Suivant</button>
    </form>   
</div>

@code {
    [Parameter]
    public EventCallback<int> OnPageSelected { get; set; }
    [Parameter]
    public EventCallback<int> Checkpoint { get; set; }
    [Parameter]
    public EventCallback<bool> BDFetched { get; set; }

    [Inject] private SingletonFormulaire SingletonForm { get; set; }

    //private string productDescription = string.Empty;
    private string productSearch = string.Empty;

    private string productDescriptionError = string.Empty;
    private string productSearchError = string.Empty;


    private List<UnspscComodite> filteredProducts = new List<UnspscComodite>();
    //private List<UnspscComodite> selectedProducts = new List<UnspscComodite>();
    private List<UnspscComodite> fetchedProducts = new List<UnspscComodite>();

    public async Task FetchDataDB()
    {
        try
        {
            // Appel à la base de données pour récupérer les régions
            fetchedProducts = await dbContext.UnspscComodites.ToListAsync();
        }
        catch (Exception ex)
        {
            productSearchError = "Erreur lors de la récupération des produits.";
            Console.WriteLine(ex.Message);
        }
        BDFetched.InvokeAsync();
    }

    // Handle the form submission
    private void HandleSubmit()
    {
        // Reset errors
        ResetErrors();

        // Basic validation checks
        var isValid = ValidateInputs();

        // If valid, export and log data to console
        if (isValid)
        {    
            Checkpoint.InvokeAsync(4);
            OnPageSelected.InvokeAsync(4);
        }
    }

    public async Task HandleSubmitReturn(int pageID)
    {
        ResetErrors(); 

        var isValid = ValidateInputs();


        if (isValid)
        {
            await OnPageSelected.InvokeAsync(pageID);
        }        
    }


    // Reset error messages
    private void ResetErrors()
    {
        productDescriptionError = string.Empty;
        productSearchError = string.Empty;
    }

    // Validate inputs
    private bool ValidateInputs()
    {
        bool isValid = true;

        if (!SingletonForm.ProduitsServicesSelectionnesInput.Any())
        {
            productSearchError = "Au moins un produit doit être sélectionné.";
            isValid = false;
        }

        return isValid;
    }

    // Export form data as an array of strings
    private string[] ExportFormData()
    {
        return new string[]
        {
            SingletonForm.DescriptionProduitsServicesInput,
            string.Join(", ", SingletonForm.ProduitsServicesSelectionnesInput)
        };
    }


    // Handle search input dynamically for products
    private void OnProductSearchInput(ChangeEventArgs e)
    {
        productSearch = e.Value?.ToString() ?? string.Empty;

        // Only perform search if there are at least 3 characters
        if (productSearch.Length >= 3)
        {
            SearchProducts();
        }
        else
        {
            filteredProducts.Clear();
        }
    }

    // Search and filter products
    private void SearchProducts()
    {
        filteredProducts.Clear();


        foreach (var produit in fetchedProducts)
        {
            if(produit.ComoditeTitreEn != null)
            {
                if (produit.ComoditeTitreFr.Contains(productSearch, StringComparison.OrdinalIgnoreCase) || produit.ComoditeNombre.Contains(productSearch, StringComparison.OrdinalIgnoreCase) || produit.ComoditeTitreEn.Contains(productSearch, StringComparison.OrdinalIgnoreCase))
                {
                    if (!SingletonForm.ProduitsServicesSelectionnesInput.Contains(produit))
                    {
                        filteredProducts.Add(produit);
                    }
                }
            }
            else
            {
                if (produit.ComoditeTitreFr.Contains(productSearch, StringComparison.OrdinalIgnoreCase) || produit.ComoditeNombre.Contains(productSearch, StringComparison.OrdinalIgnoreCase))
                {
                    if (!SingletonForm.ProduitsServicesSelectionnesInput.Contains(produit))
                    {
                        filteredProducts.Add(produit);
                    }
                }
            }
        }
    }

    // Select a product from the search results
    private void SelectProduct(UnspscComodite product)
    {
        if (!SingletonForm.ProduitsServicesSelectionnesInput.Contains(product))
        {
            SingletonForm.ProduitsServicesSelectionnesInput.Add(product);
            productSearch = string.Empty; // Clear the search input after selection
            filteredProducts.Clear(); // Clear search results after selection
        }
    }

    // Remove a product from the selected list
    private void RemoveProduct(UnspscComodite product)
    {
        SingletonForm.ProduitsServicesSelectionnesInput.Remove(product);
    }

    // Log data to the console using Console.WriteLine
    private void LogToConsole(string[] formData)
    {
        Console.WriteLine($"Description du produit: {formData[0]}");
        Console.WriteLine($"Produits sélectionnés: {formData[1]}");
    }
}
